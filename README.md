# Генетический Алгоритм

В заголовочном файле [`GeneticAlgo.h`](GeneticAlgo.h) реализована функциональность, необходимая для генетического алгоритма. В генетических алгоритмах имитируется естественный отбор в популяции на протяжении многих поколений.

Алгоритм реализован в виде:
* головного класса, реализующего основной цикл ГА
* абстрактных классов для операций ГА и вычисления функции выживаемости
* конкретных классов, реализующих операции ГА и вычисление функции выживаемости

С помощью алгоритма решается задача минимизации заданного критерия на клеточном автомате (см. ниже).

Уточнение схемы: по ходу выполнения алгоритма запоминается лучшее из найденных решений и, если найдено лучше, обновляется. При этом оно НЕ включается в обязательном порядке в каждую из последующих популяций. Смысл - не потерять лучшее решение, найденное на какой-то из промежуточных итераций ГА.

В файле [`GenAlgo.cpp`](GenAlgo.cpp) реализован функционал для исследования зависимости стабильности и качества решения, а также вычислительных затрат на выполнение алгоритма, от интенсивности мутации.

## Конкретизация алгоритмя

**Функция выживаемости:** значение оптимизируемого критерия с добавлением штрафа.

**Размер популяции:** Npop=100.

Кодирование решения битовым вектором: очевидное, с учётом того что у каждой клетки поля два возможных значения.

**Начальная популяция:** полностью случайно генерируется, вероятность того что в клетке "1" равна 0,5.

**Операция мутации:** каждый бит решения мутирует (инвертируется) с вероятностью Pmut. Значение Pmut изменяется в ходе исследования (см. ниже). В ходе конкретного выполнения алгоритма Pmut должно быть зафиксировано.

**Операция селекции:**
пропорциональная селекция

**Операция скрещивания:**
двухточечное скрещивание

**Вероятность скрещивания:** 0.8

Критерий останова: 50 итераций ГА (т.е. 50 смен популяций) подряд без улучшения значения оптимизируемого критерия *на лучшем из найденных решений*. То есть 50 итераций подряд не удалось найти решение с меньшим значением критерия, чем у ранее запомненного лучшего из ранее найденных решений.

# Решаемая задача

Описанная ниже игра "Жизнь" раализована в заголовочном файле [`GameOfLife.h`](GameOfLife.h).

Имеется поле размером 50х50 квадратных клеток. Каждая клетка может быть либо заполненной (значение "1"), либо пустой (значение "0"). Конкретное сочетание заполненных и пустых клеток поля называется конфигурацией (или состоянием) клеточного автомата.

У каждой конфигурации есть "потомок". Он определяется по правилам клеточного автомата Дж. Конвея "Жизнь" (https://ru.wikipedia.org/wiki/Игра_«Жизнь»). Замена конфигурации на её потомка называется шагом клеточного автомата.

Ограниченность поля учитывается следующим образом: для клетки, находящейся на границе поля (в т.ч. в углу), её соседи, находящиеся за границей поля, считаются всегда пустыми. Как если бы поле было окружено рамкой из постоянных "нулей".

Среди конфигураций, удовлетворяющих заданному ограничению, ТРЕБУЕТСЯ найти ту, на которой минимизируется значение заданного критерия.

Критерий: количество заполненных клеток после 100 шагов клеточного автомата (т.е. в 101-й конфигурации, в нумерации с 1).

Ограничение: конфигурация, возникающая после 100 шагов клеточного автомата, не является стационарной. Т.е. её потомок (результат следующего шага клеточного автомата) не совпадает с ней.

# Исследование

Все входные данные описаны выше и являются, в основном, настройками алгоритма.

Исследовалась зависимость характеристик работы алгоритма от интенсивности мутации, т.е. от значения Pmut.
Начальное значение Pmut: Pmut_init = 1/(50*50) = 0.0004, т.е. в среднем в каждом решении мутирует 1 бит. 

Pmut в ходе исследования изменялось по формуле: 
Pmut(i)=Pmut_init*(1.5^i), i=0, ..., 9; 
i - номер серии экспериментов, т.е. нужно провести 10 серий экспериментов, каждая со своим фиксированным значением Pmut. Например, в серии 3 Pmut=Pmut(3)=0.0004*(1.5^3)=0.00135

Для каждого значения i проводилась серия из 10 запусков ГА с соответствующим значением Pmut=Pmut(i) и определялись:
* стабильность алгоритма (разброс значений критерия на решении-результате, т.е. разность между значениями критерия на худшем и на лучшем прогоне)
* качество работы алгоритма (значение критерия на лучшем прогоне)
* вычислительные затраты на выполнение алгоритма (количество процессорного времени, затраченного на прогон; взято максимум по 10 прогонам)

## Визуализация

В папке [`res/`](res/) для каждого прогона алгоритма в файл сохранено наилучшее найденное решение, а также результат работы клеточного автомата через 100 шагов. Сохранялось в виде матрицы 50х50, где "-" - незаполненная клетка, "Х" - заполненная. Пример матрицы 3х3 ("планер"):

-Х-
Х--  
ХХХ

В текстовом терминале реализована **пошаговая визуализация** работы клеточного автомата на наилучшем найденном решении (взятом как начальное состояние) в течение 100 шагов. Формат вывода матрицы - как для файла (см. выше). Частота смены состояний - два состояния в секунду. Перерисовывается поле "красиво и на том же месте", а не прокруткой экрана.

